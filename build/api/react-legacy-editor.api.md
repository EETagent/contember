## API Report File for "@contember/react-legacy-editor"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="react" />

import { Ancestor } from 'slate';
import { BaseEditor } from 'slate';
import { ChildrenAnalyzer } from '@contember/react-multipass-rendering';
import { ComponentType } from 'react';
import { Context } from 'react';
import { Descendant } from 'slate';
import { Editor as Editor_2 } from 'slate';
import { EditorInterface } from 'slate';
import { Transforms as EditorTransforms } from 'slate';
import { Element as Element_2 } from 'slate';
import { EntityAccessor } from '@contember/react-binding';
import { EntityId } from '@contember/react-binding';
import type { Environment } from '@contember/react-binding';
import { FieldAccessor } from '@contember/react-binding';
import { FieldBasicProps } from '@contember/react-binding';
import { FieldValue } from '@contember/react-binding';
import type { FocusEvent as FocusEvent_2 } from 'react';
import { FunctionComponent } from 'react';
import { HistoryEditor } from 'slate-history';
import { JSX as JSX_2 } from 'react/jsx-runtime';
import type { KeyboardEvent as KeyboardEvent_2 } from 'react';
import { Location as Location_2 } from 'slate';
import { NamedExoticComponent } from 'react';
import { Node as Node_2 } from 'slate';
import { NodeEntry } from 'slate';
import type { OptionallyVariableFieldValue } from '@contember/react-binding';
import { Path } from 'slate';
import { PathRef } from 'slate';
import { Point } from 'slate';
import { Range as Range_2 } from 'slate';
import { ReactEditor } from 'slate-react';
import { ReactElement } from 'react';
import { ReactNode } from 'react';
import { RelativeSingleField } from '@contember/react-binding';
import { RenderElementProps } from 'slate-react';
import { RenderLeafProps } from 'slate-react';
import type { Scalar } from '@contember/react-binding';
import { Selection as Selection_2 } from 'slate';
import * as Slate from 'slate';
import { SugaredFieldProps } from '@contember/react-binding';
import { SugaredRelativeEntityList } from '@contember/react-binding';
import type { Text as Text_2 } from 'slate';

// @public (undocumented)
export type AlignDirection = 'start' | 'center' | 'end' | 'justify' | undefined;

// @public (undocumented)
export interface AnchorElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    href: string;
    // (undocumented)
    type: typeof anchorElementType;
}

// @public (undocumented)
export const anchorElementPlugin: ({ render }: {
    render: ElementRenderer<AnchorElement>;
}) => CustomElementPlugin<AnchorElement>;

// @public (undocumented)
export const anchorElementType: "anchor";

// @public (undocumented)
export const anchorHtmlDeserializer: HtmlDeserializerPlugin;

// Warning: (ae-unresolved-link) The @link reference could not be resolved: The package "@contember/react-legacy-editor" does not have an export "BlockRepeater"
// Warning: (ae-unresolved-link) The @link reference could not be resolved: The package "@contember/react-legacy-editor" does not have an export "DiscriminatedBlocks"
//
// @public
export const Block: FunctionComponent<BlockProps>;

// @public (undocumented)
export const blockAnalyzer: ChildrenAnalyzer<BlockProps, never, Environment<Environment.AnyNode | undefined>>;

// @public
export const BlockEditor: FunctionComponent<BlockEditorProps> & {
    ContentOutlet: (props: ContentOutletProps) => ReactElement | null;
};

// @public (undocumented)
export interface BlockEditorProps extends SugaredRelativeEntityList, CreateEditorPublicOptions {
    // (undocumented)
    children?: ReactNode;
    // (undocumented)
    contentField: SugaredFieldProps['field'];
    // (undocumented)
    embedContentDiscriminationField?: SugaredFieldProps['field'];
    // (undocumented)
    embedHandlers?: Iterable<EmbedHandler>;
    // (undocumented)
    embedReferenceDiscriminateBy?: SugaredDiscriminateBy;
    // (undocumented)
    monolithicReferencesMode?: boolean;
    // (undocumented)
    referenceDiscriminationField?: SugaredFieldProps['field'];
    // (undocumented)
    referencesField?: SugaredRelativeEntityList | string;
    // (undocumented)
    renderReference?: ComponentType<ReferenceElementRendererProps>;
    // Warning: (ae-forgotten-export) The symbol "OverrideRenderElementOptions" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    renderSortableBlock: OverrideRenderElementOptions['renderSortableBlock'];
    // (undocumented)
    sortableBy: SugaredFieldProps['field'];
}

// @public (undocumented)
export interface BlockProps {
    // (undocumented)
    alternate?: ReactNode;
    // (undocumented)
    children?: ReactNode;
    // (undocumented)
    description?: ReactNode;
    discriminateBy: SugaredDiscriminateBy;
    // (undocumented)
    label?: ReactNode;
}

// @public (undocumented)
export const boldMark = "isBold";

// @public (undocumented)
export const codeMark = "isCode";

// @public (undocumented)
export const ContemberEditor: {
    addMarks: <T extends EditorText, E extends Editor>(editor: E, marks: TextSpecifics<T>) => void;
    canToggleMark: <T_1 extends EditorText, E_1 extends Editor>(editor: E_1, markName: string, markValue?: unknown) => boolean;
    closest: <E_2 extends Editor>(editor: E_2, options: {
        at?: Location_2 | undefined;
        match: (node: EditorElement | Editor) => boolean;
    }) => NodeEntry<EditorElement | Editor> | undefined;
    closestBlockEntry: <E_3 extends Editor>(editor: E_3, options?: {
        at?: Location_2 | undefined;
        match?: ((node: EditorElement) => boolean) | undefined;
    } | undefined) => NodeEntry<EditorElement | Editor> | undefined;
    closestViableBlockContainerEntry: <E_4 extends Editor>(editor: E_4, options?: {
        at?: Location_2 | undefined;
    } | undefined) => NodeEntry<EditorElement | Editor> | undefined;
    ejectElement: <E_5 extends Editor>(editor: E_5, path: Path) => void;
    elementToSpecifics: <Element_1 extends EditorElement = EditorElement>(element: Element_1) => Partial<Element_1>;
    getElementDataAttributes: <Element_2 extends EditorElement = EditorElement>(element: Element_2, attributeNamePrefix?: string) => ElementDataAttributes;
    getPreviousSibling: <E_6 extends Editor = Editor, CurrentNode extends Node_2 = Node_2, PreviousNode extends Node_2 = CurrentNode>(editor: E_6, node: CurrentNode, nodePath: Path) => NodeEntry<PreviousNode> | undefined;
    hasMarks: <T_2 extends EditorText, E_7 extends Editor>(editor: E_7, marks: TextSpecifics<T_2>, options?: {
        from?: Path | undefined;
        to?: Path | undefined;
    }) => boolean;
    hasParentOfType: <Editor extends Editor, Element_3 extends EditorElement>(editor: Editor, nodeEntry: NodeEntry<Node_2>, type: Element_3["type"], suchThat?: Partial<Element_3> | undefined) => boolean;
    isElementType: <Element_4 extends EditorElement>(element: Node_2, type: Element_4["type"], suchThat?: Partial<Element_4> | undefined) => boolean;
    permissivelyDeserializeNodes: <E_8 extends Editor>(editor: E_8, serializedElement: string, errorMessage?: string | undefined) => (EditorElement | EditorText)[];
    removeMarks: <T_3 extends EditorText, E_9 extends Editor>(editor: E_9, marks: TextSpecifics<T_3>) => void;
    serializeNodes: <E_10 extends Editor>(editor: E_10, elements: (EditorElement | EditorText)[], errorMessage?: string | undefined) => string;
    strictlyDeserializeNodes: <E_11 extends Editor>(editor: E_11, serializedElement: string, errorMessage?: string | undefined) => (EditorElement | EditorText)[];
    textToSpecifics: <Text_1 extends EditorText = EditorText>(textNode: Text_1) => TextSpecifics<Text_1>;
    toLatestFormat: <E_12 extends Editor>(editor: E_12, potentiallyOldNode: SerializableEditorNode) => SerializableEditorNode;
    topLevelNodes: <E_13 extends Editor>(editor: E_13) => Generator<NodeEntry<Node_2>, void, undefined>;
};

// @public (undocumented)
export interface ContentOutletProps {
    // (undocumented)
    placeholder?: string;
}

// @public (undocumented)
export const createAlignHandler: (direction: AlignDirection) => {
    isActive?: ((args: {
        editor: Editor_2;
    }) => boolean) | undefined;
    shouldDisplay?: ((args: {
        editor: Editor_2;
    }) => boolean) | undefined;
    toggle: (args: {
        editor: Editor_2;
    }) => void;
};

// @public (undocumented)
export interface CreateEditorOptions extends OverrideCreateElementReferenceOptions, ReferenceElementOptions, OverrideInsertDataOptions, OverrideRenderElementOptions, OverrideInsertElementWithReferenceOptions, CreateEditorPublicOptions {
}

// @public (undocumented)
export interface CreateEditorPublicOptions {
    // (undocumented)
    plugins?: ((baseEditor: Editor_2) => Editor_2 | void)[];
}

// @public (undocumented)
export const createEditorWithEssentials: (defaultElementType: string) => Editor_2;

// @public (undocumented)
export type CreateElementReferences = (editor: Editor_2, targetPath: Slate.Path, referenceDiscriminant: FieldValue, initialize?: EntityAccessor.BatchUpdatesHandler) => EntityAccessor;

// @public (undocumented)
export const createEmptyTableCellElement: () => {
    type: "tableCell";
    children: {
        text: string;
    }[];
};

// @public (undocumented)
export const createEmptyTableElement: (rowCount?: number, columnCount?: number) => {
    type: "table";
    children: {
        type: "tableRow";
        children: {
            type: "tableCell";
            children: {
                text: string;
            }[];
        }[];
    }[];
};

// @public (undocumented)
export const createEmptyTableRowElement: (columnCount?: number) => {
    type: "tableRow";
    children: {
        type: "tableCell";
        children: {
            text: string;
        }[];
    }[];
};

// @public (undocumented)
export const createMarkHtmlDeserializer: (markType: string, tagMatcher: (el: HTMLElement) => boolean, attributeMatcher: (el: HTMLElement) => boolean) => HtmlDeserializerPlugin;

// @public (undocumented)
export const createReferenceElementPlugin: (args: ReferenceElementOptions) => CustomElementPlugin<ReferenceElement>;

// @public (undocumented)
export interface CustomElementPlugin<T extends Element_2> {
    // (undocumented)
    acceptsAttributes?: (args: {
        editor: Editor_2;
        suchThat: Partial<T>;
    }) => boolean;
    // (undocumented)
    canContainAnyBlocks?: boolean;
    // (undocumented)
    isActive?: (args: {
        editor: Editor_2;
        suchThat?: Partial<T>;
    }) => boolean;
    // (undocumented)
    isInline?: boolean;
    // (undocumented)
    isVoid?: boolean | ((args: {
        element: T;
        editor: Editor_2;
    }) => boolean);
    // (undocumented)
    normalizeNode?: (args: {
        element: T;
        path: Path;
        editor: Editor_2;
        preventDefault: () => void;
    }) => void;
    // (undocumented)
    render: ElementRenderer<T>;
    // (undocumented)
    toggleElement?: (args: {
        editor: Editor_2;
        suchThat?: Partial<T>;
    }) => void;
    // (undocumented)
    type: T['type'];
}

// @public (undocumented)
export interface CustomMarkPlugin {
    // (undocumented)
    isHotKey: (e: KeyboardEvent) => boolean;
    // (undocumented)
    render: FunctionComponent<RenderLeafProps>;
    // (undocumented)
    type: string;
}

// @public (undocumented)
export const DefaultElement: FunctionComponent<DefaultElementProps>;

// @public (undocumented)
export interface DefaultElementProps extends RenderElementProps {
}

// @public (undocumented)
export interface DiscriminatedDatum {
    // (undocumented)
    discriminateBy: SugaredDiscriminateBy;
}

// @public (undocumented)
export type Editor = EditorWithEssentials<ReactEditor & HistoryEditor & BaseEditor>;

// @public (undocumented)
export type EditorAncestor = Ancestor;

// @public (undocumented)
export type EditorDefaultElementFactory = (children: Descendant[]) => Element_2;

// @public (undocumented)
export type EditorDescendant = Descendant;

// @public (undocumented)
export type EditorElement = {
    [K in string]: unknown;
} & {
    type: string;
    children: Array<Descendant>;
};

// @public (undocumented)
export class EditorPasteUtils {
    // (undocumented)
    static flattenNodesWithType(withType: NodesWithType[], defaultElementFactory: EditorDefaultElementFactory): NodesWithType;
    // (undocumented)
    static wordPasteListItemContent(allNodes: Iterable<Node> | ArrayLike<Node>): Node[];
}

// @public (undocumented)
export type EditorPath = Path;

// @public (undocumented)
export type EditorPoint = Point;

// @public (undocumented)
export type EditorRange = Range_2;

// @public (undocumented)
export interface EditorReferenceBlock extends BlockProps {
    // (undocumented)
    template: EditorTemplate;
}

// @public (undocumented)
export type EditorReferenceBlocks = NormalizedDiscriminatedData<EditorReferenceBlock>;

// @internal (undocumented)
export const EditorReferenceBlocksContext: Context<EditorReferenceBlocks>;

// @public (undocumented)
export type EditorRenderElementProps = RenderElementProps;

// @public (undocumented)
export type EditorSelection = Selection_2;

// @public (undocumented)
export type EditorTemplate = undefined | {
    blockContent: EditorTemplateAtom<ContentOutletProps> | undefined;
};

// @public (undocumented)
export type EditorText = {
    [K in string]: unknown;
} & {
    text: string;
};

export { EditorTransforms }

// @public (undocumented)
export const EditorUtils: EditorInterface;

// @public (undocumented)
export type EditorWithBlocks = Editor_2 & WithBlockElements;

// @public (undocumented)
export type EditorWithEssentials<E extends BaseEditor> = WithEssentials & E;

// @public (undocumented)
export const ejectHeadingElement: (editor: Editor_2, elementPath: Path) => void;

// @public (undocumented)
export interface ElementDataAttributes {
    // (undocumented)
    [dataAttribute: string]: Scalar;
}

// @public (undocumented)
export type ElementRenderer<T extends Element_2> = FunctionComponent<RenderElementProps & {
    element: T;
}>;

// @public (undocumented)
export interface ElementWithReference extends Element_2 {
    // (undocumented)
    referenceId: EntityId;
}

// @public (undocumented)
export interface EmbedHandler<EmbedArtifacts = any> {
    // (undocumented)
    debugName: string;
    // (undocumented)
    discriminateBy: SugaredDiscriminateBy;
    // (undocumented)
    handleSource: (source: string, url: URL | undefined) => undefined | EmbedArtifacts | Promise<EmbedArtifacts | undefined>;
    // (undocumented)
    populateEmbedData: (options: PopulateEmbedDataOptions<EmbedArtifacts>) => void;
    // (undocumented)
    renderEmbed: () => ReactNode;
    // (undocumented)
    staticRender: (environment: Environment) => ReactNode;
}

// @public (undocumented)
export const EmbedHandlers: {
    GoogleForm: typeof GoogleFormEmbedHandler;
    YouTube: typeof YouTubeEmbedHandler;
    Vimeo: typeof VimeoEmbedHandler;
    SoundCloud: typeof SoundCloudEmbedHandler;
    Spotify: typeof SpotifyEmbedHandler;
};

// @public (undocumented)
export const getDiscriminatedBlock: (blocks: NormalizedBlocks, field: FieldAccessor | FieldValue) => ResolvedDiscriminatedDatum<BlockProps> | undefined;

// @public (undocumented)
export const getDiscriminatedDatum: <Datum>(data: NormalizedDiscriminatedData<Datum>, discriminant: FieldAccessor | FieldValue) => ResolvedDiscriminatedDatum<Datum> | undefined;

// @public (undocumented)
export const getTableElementColumnCount: (element: TableElement) => number;

// @public (undocumented)
export const getTableElementRowCount: (element: TableElement) => number;

// @public (undocumented)
export interface HeadingElement extends Element_2 {
    // (undocumented)
    align?: AlignDirection;
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    isNumbered?: boolean;
    // (undocumented)
    level: 1 | 2 | 3 | 4 | 5 | 6;
    // (undocumented)
    type: typeof headingElementType;
}

// @public (undocumented)
export const headingElementPlugin: ({ render }: {
    render: ElementRenderer<HeadingElement>;
}) => CustomElementPlugin<HeadingElement>;

// @public (undocumented)
export const headingElementType: "heading";

// @public (undocumented)
export const headingHtmlDeserializer: HtmlDeserializerPlugin;

// @public (undocumented)
export const highlightMark = "isHighlighted";

// @public (undocumented)
export interface HorizontalRuleElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    type: typeof horizontalRuleElementType;
}

// @public (undocumented)
export const horizontalRuleElementPlugin: ({ render }: {
    render: ElementRenderer<HorizontalRuleElement>;
}) => CustomElementPlugin<HorizontalRuleElement>;

// @public (undocumented)
export const horizontalRuleElementType: "horizontalRule";

// @public (undocumented)
export class HtmlDeserializer {
    constructor(createDefaultElement: EditorDefaultElementFactory, plugins: HtmlDeserializerPlugin[]);
    // (undocumented)
    createDefaultElement: EditorDefaultElementFactory;
    // (undocumented)
    deserializeBlocks(list: Node[], cumulativeTextAttrs: TextAttrs): Descendant[];
    // (undocumented)
    deserializeInline(list: NodeList | Node[], cumulativeTextAttrs: TextAttrs): Descendant[];
    // (undocumented)
    processNodeListPaste(nodeList: Node[], cumulativeTextAttrs: TextAttrs): {
        texts: Descendant[];
        elements?: undefined;
    } | {
        elements: EditorElement[];
        texts?: undefined;
    } | null;
    // (undocumented)
    registerPlugin(plugin: HtmlDeserializerPlugin, prepend?: boolean): void;
}

// @public (undocumented)
export type HtmlDeserializerNextCallback = (children: NodeList | Node[], cumulativeTextAttrs: TextAttrs) => Descendant[];

// @public (undocumented)
export interface HtmlDeserializerPlugin {
    // (undocumented)
    processAttributesPaste?: (args: {
        deserializer: HtmlDeserializer;
        element: HTMLElement;
        cumulativeTextAttrs: TextAttrs;
    }) => TextAttrs;
    // (undocumented)
    processBlockPaste?: (args: {
        deserializer: HtmlDeserializer;
        element: HTMLElement;
        next: HtmlDeserializerNextCallback;
        cumulativeTextAttrs: TextAttrs;
    }) => Element_2[] | Element_2 | null;
    // (undocumented)
    processInlinePaste?: (args: {
        deserializer: HtmlDeserializer;
        element: HTMLElement;
        next: HtmlDeserializerNextCallback;
        cumulativeTextAttrs: TextAttrs;
    }) => Descendant[] | Descendant | null;
    // (undocumented)
    processNodeListPaste?: (args: {
        deserializer: HtmlDeserializer;
        nodeList: Node[];
        cumulativeTextAttrs: TextAttrs;
    }) => NodesWithType;
}

// @public (undocumented)
export const initBlockEditor: ({ editor, ...options }: CreateEditorOptions & {
    editor: Editor_2;
}) => Editor;

// @public (undocumented)
export type InsertElementWithReference = (element: Omit<Element_2, 'referenceId'>, referenceDiscriminant: FieldValue, initialize?: EntityAccessor.BatchUpdatesHandler) => void;

// @public (undocumented)
export const isAnchorElement: (element: Node_2) => element is AnchorElement;

// @public (undocumented)
export const isAnchorElementActive: (editor: Editor_2) => boolean;

// @public (undocumented)
export const isElementWithReference: (candidate: Node_2) => candidate is ElementWithReference;

// @public (undocumented)
export const isHeadingElement: (element: Node_2, suchThat?: Partial<HeadingElement>) => element is HeadingElement;

// @public (undocumented)
export const isHorizontalRuleElement: (element: Node_2) => element is HorizontalRuleElement;

// @public (undocumented)
export const isHorizontalRuleElementActive: (editor: Editor_2) => boolean;

// @public (undocumented)
export const isListItemElement: (element: Node_2, suchThat?: Partial<ListItemElement>) => element is ListItemElement;

// @public (undocumented)
export const isOrderedListElement: (element: Node_2, suchThat?: Partial<OrderedListElement>) => element is OrderedListElement;

// @public (undocumented)
export const isParagraphElement: (element: Node_2, suchThat?: Partial<ParagraphElement>) => element is ParagraphElement;

// @public (undocumented)
export const isReferenceElement: (node: Node_2) => node is ReferenceElement;

// @public (undocumented)
export const isScrollTargetElement: (element: Node_2) => element is ScrollTargetElement;

// @public (undocumented)
export const isScrollTargetElementActive: (editor: Editor_2) => boolean;

// @public (undocumented)
export const isTableCellElement: (element: Node_2) => element is TableCellElement;

// @public (undocumented)
export const isTableElement: (element: Node_2) => element is TableElement;

// @public (undocumented)
export const isTableRowElement: (element: Node_2) => element is TableRowElement;

// @public (undocumented)
export const isUnorderedListElement: (element: Node_2, suchThat?: Partial<UnorderedListElement>) => element is UnorderedListElement;

// @public (undocumented)
export const italicMark = "isItalic";

// @public (undocumented)
export interface ListElementProperties {
    // (undocumented)
    ordered: boolean;
    // (undocumented)
    properties: Record<string, unknown>;
}

// @public (undocumented)
export const listHtmlDeserializerFactory: ({ getListElementProperties }?: ListHtmlDeserializerOptions) => HtmlDeserializerPlugin;

// @public (undocumented)
export interface ListHtmlDeserializerOptions {
    // (undocumented)
    getListElementProperties?: (text: string) => ListElementProperties;
}

// @public (undocumented)
export interface ListItemElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    type: typeof listItemElementType;
}

// @public (undocumented)
export const listItemElementPlugin: ({ render }: {
    render: ElementRenderer<ListItemElement>;
}) => CustomElementPlugin<ListItemElement>;

// @public (undocumented)
export const listItemElementType: "listItem";

// @public (undocumented)
export type NodesWithType = NodesWithTypeFiltered | null;

// @public (undocumented)
export type NodesWithTypeFiltered = {
    texts: Descendant[];
    elements?: undefined;
} | {
    elements: Element_2[];
    texts?: undefined;
};

// @public (undocumented)
export type NormalizedBlocks = NormalizedDiscriminatedData<BlockProps>;

// @public (undocumented)
export type NormalizedDiscriminatedData<Datum> = Map<FieldValue, ResolvedDiscriminatedDatum<Datum>>;

// @public (undocumented)
export type NormalizedEmbedHandlers = NormalizedDiscriminatedData<EmbedHandler>;

// @public (undocumented)
export interface OrderedListElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    type: typeof orderedListElementType;
}

// @public (undocumented)
export const orderedListElementPlugin: ({ render }: {
    render: ElementRenderer<OrderedListElement>;
}) => CustomElementPlugin<OrderedListElement>;

// @public (undocumented)
export const orderedListElementType: "orderedList";

// @public (undocumented)
export interface OverrideCreateElementReferenceOptions {
    // (undocumented)
    createElementReferences: CreateElementReferences;
}

// @public (undocumented)
export const overrideDeleteBackward: <E extends Editor>(editor: E) => void;

// @public (undocumented)
export interface OverrideInsertDataOptions {
    // (undocumented)
    embedContentDiscriminationField: RelativeSingleField | undefined;
    // (undocumented)
    embedHandlers: NormalizedEmbedHandlers | undefined;
    // (undocumented)
    embedReferenceDiscriminateBy: FieldValue | undefined;
}

// @public (undocumented)
export interface OverrideInsertElementWithReferenceOptions {
    // (undocumented)
    insertElementWithReference: InsertElementWithReference;
}

// @public (undocumented)
export interface ParagraphElement extends Element_2 {
    // (undocumented)
    align?: AlignDirection;
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    isNumbered?: boolean;
    // (undocumented)
    type: typeof paragraphElementType;
}

// @public (undocumented)
export const paragraphElementPlugin: ({ render }: {
    render: ElementRenderer<ParagraphElement>;
}) => CustomElementPlugin<ParagraphElement>;

// @public (undocumented)
export const paragraphElementType: "paragraph";

// @public (undocumented)
export const paragraphHtmlDeserializer: HtmlDeserializerPlugin;

// @public (undocumented)
export interface PopulateEmbedDataOptions<EmbedArtifacts = any> {
    // (undocumented)
    embedArtifacts: EmbedArtifacts;
    // (undocumented)
    entity: EntityAccessor;
    // (undocumented)
    source: string;
}

// @public (undocumented)
export const prepareElementForInsertion: (editor: Editor_2, node: Node_2) => Path;

// @public (undocumented)
export interface ReferenceElement extends ElementWithReference {
    // (undocumented)
    type: typeof referenceElementType;
}

// @public (undocumented)
export interface ReferenceElementOptions {
    // (undocumented)
    editorReferenceBlocks: EditorReferenceBlocks;
    // (undocumented)
    embedContentDiscriminationField: RelativeSingleField | undefined;
    // (undocumented)
    embedHandlers: NormalizedEmbedHandlers | undefined;
    // (undocumented)
    embedReferenceDiscriminateBy: FieldValue | undefined;
    // (undocumented)
    embedSubBlocks: NormalizedBlocks | undefined;
    // (undocumented)
    getReferencedEntity: (path: Path, referenceId: EntityId) => EntityAccessor;
    // (undocumented)
    referenceDiscriminationField: RelativeSingleField | undefined;
    // (undocumented)
    renderReference: ComponentType<ReferenceElementRendererProps> | undefined;
}

// @public (undocumented)
export interface ReferenceElementRendererProps extends RenderElementProps, ReferenceElementOptions {
    // (undocumented)
    element: ReferenceElement;
    // (undocumented)
    referenceDiscriminationField: RelativeSingleField;
}

// @public (undocumented)
export const referenceElementType: "reference";

// @public (undocumented)
export interface ResolvedDiscriminatedDatum<Datum> {
    // (undocumented)
    datum: Datum;
    // (undocumented)
    discriminateBy: FieldValue;
}

// @public
export const RichTextEditor: FunctionComponent<RichTextEditorProps>;

// @public (undocumented)
export type RichTextEditorProps = FieldBasicProps & CreateEditorPublicOptions & {
    children: React.ReactNode;
};

// @public (undocumented)
export interface ScrollTargetElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    identifier: string;
    // (undocumented)
    type: typeof scrollTargetElementType;
}

// @public (undocumented)
export const scrollTargetElementPlugin: ({ render }: {
    render: ElementRenderer<ScrollTargetElement>;
}) => CustomElementPlugin<ScrollTargetElement>;

// @public (undocumented)
export const scrollTargetElementType: "scrollTarget";

// @public (undocumented)
export interface SerializableEditorNode {
    // (undocumented)
    children: Array<Element_2 | Text_2>;
    // (undocumented)
    formatVersion: number;
}

// @public (undocumented)
export const SortedBlocksContext: Context<EntityAccessor[]>;

// @public (undocumented)
export const strikeThroughMark = "isStruckThrough";

// @public (undocumented)
export type SugaredDiscriminateBy = OptionallyVariableFieldValue;

// @public (undocumented)
export interface TableCellElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    headerScope?: 'row';
    // (undocumented)
    justify?: 'start' | 'center' | 'end';
    // (undocumented)
    type: typeof tableCellElementType;
}

// @public (undocumented)
export const tableCellElementPlugin: ({ render }: {
    render: ElementRenderer<TableCellElement>;
}) => CustomElementPlugin<TableCellElement>;

// @public (undocumented)
export const tableCellElementType: "tableCell";

// @public (undocumented)
export interface TableElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    type: typeof tableElementType;
}

// @public (undocumented)
export const tableElementPlugin: ({ render }: {
    render: ElementRenderer<TableElement>;
}) => CustomElementPlugin<TableElement>;

// @public (undocumented)
export const tableElementType: "table";

// @public (undocumented)
export class TableModifications {
    // (undocumented)
    static addTableColumn(editor: Editor_2, element: TableElement, index?: number): void;
    // (undocumented)
    static addTableRow(editor: Editor_2, element: TableElement, index?: number): void;
    // (undocumented)
    static deleteTableColumn(editor: Editor_2, element: TableElement, index: number): void;
    // (undocumented)
    static deleteTableRow(editor: Editor_2, element: TableElement, index: number): void;
    // (undocumented)
    static justifyTableColumn(editor: Editor_2, element: TableElement, columnIndex: number, direction: TableCellElement['justify']): void;
    // (undocumented)
    static toggleTableColumnHeaderScope(editor: Editor_2, element: TableElement, columnIndex: number, scope: TableCellElement['headerScope']): void;
    // (undocumented)
    static toggleTableRowHeaderScope(editor: Editor_2, element: TableElement, rowIndex: number, scope: TableRowElement['headerScope']): void;
}

// @public (undocumented)
export interface TableRowElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    headerScope?: 'table';
    // (undocumented)
    type: typeof tableRowElementType;
}

// @public (undocumented)
export const tableRowElementPlugin: ({ render }: {
    render: ElementRenderer<TableRowElement>;
}) => CustomElementPlugin<TableRowElement>;

// @public (undocumented)
export const tableRowElementType: "tableRow";

// @public (undocumented)
export interface TextAttrs {
    // (undocumented)
    [key: string]: any;
}

// @public (undocumented)
export type TextSpecifics<Text extends Text_2> = Omit<Text, 'text'>;

// @public (undocumented)
export const underlineMark = "isUnderlined";

// @public (undocumented)
export interface UnorderedListElement extends Element_2 {
    // (undocumented)
    children: Editor_2['children'];
    // (undocumented)
    type: typeof unorderedListElementType;
}

// @public (undocumented)
export const unorderedListElementPlugin: ({ render }: {
    render: ElementRenderer<UnorderedListElement>;
}) => CustomElementPlugin<UnorderedListElement>;

// @public (undocumented)
export const unorderedListElementType: "unorderedList";

// @public (undocumented)
export const useBlockEditorSlateNodes: ({ editor, blockElementCache, blockElementPathRefs, blockContentField, topLevelBlocks, }: UseBlockEditorSlateNodesOptions) => Descendant[];

// @public (undocumented)
export interface UseBlockEditorSlateNodesOptions {
    // (undocumented)
    blockContentField: SugaredFieldProps['field'];
    // (undocumented)
    blockElementCache: WeakMap<EntityAccessor, Element_2>;
    // (undocumented)
    blockElementPathRefs: Map<EntityId, PathRef>;
    // (undocumented)
    editor: Editor_2;
    // (undocumented)
    topLevelBlocks: EntityAccessor[];
}

// @public (undocumented)
export const useBlockProps: (children: ReactNode) => BlockProps[];

// @public (undocumented)
export const useDiscriminatedData: <Datum extends DiscriminatedDatum = DiscriminatedDatum>(source: Iterable<Datum>) => NormalizedDiscriminatedData<Datum>;

// @public (undocumented)
export const useEditor: () => Editor;

// @public (undocumented)
export const useEditorReferenceBlocks: () => EditorReferenceBlocks;

// @public (undocumented)
export const useNormalizedBlocks: (children: ReactNode) => NormalizedBlocks;

// @public (undocumented)
export const withAnchors: ({ render }: {
    render: ElementRenderer<AnchorElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export interface WithBlockElements {
    // (undocumented)
    createElementReference: (targetPath: Slate.Path, referenceDiscriminant: FieldValue, initialize?: EntityAccessor.BatchUpdatesHandler) => EntityAccessor;
    // (undocumented)
    getReferencedEntity: (referenceId: string) => EntityAccessor;
    // (undocumented)
    insertElementWithReference: <Element extends Slate.Element>(element: Omit<Element, 'referenceId'>, referenceDiscriminant: FieldValue, initialize?: EntityAccessor.BatchUpdatesHandler) => void;
    // (undocumented)
    slate: typeof Slate;
}

// @public (undocumented)
export const withBold: <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withCode: <E extends Editor>(editor: E) => E;

// @public (undocumented)
export interface WithEssentials {
    // (undocumented)
    acceptsAttributes: <E extends Element_2>(elementType: E['type'], suchThat: Partial<E>) => boolean;
    // (undocumented)
    canContainAnyBlocks: (element: Element_2 | Editor_2) => boolean;
    // (undocumented)
    canToggleElement: <E extends Element_2>(elementType: E['type'], suchThat?: Partial<E>) => boolean;
    // (undocumented)
    canToggleMarks: <T extends Text_2>(marks: TextSpecifics<T>) => boolean;
    // (undocumented)
    createDefaultElement: EditorDefaultElementFactory;
    // (undocumented)
    defaultElementType: string;
    // (undocumented)
    deserializeNodes: (serializedNodes: string, errorMessage?: string) => Array<Element_2 | Text_2>;
    // (undocumented)
    formatVersion: number;
    // (undocumented)
    hasMarks: <T extends Text_2>(marks: TextSpecifics<T>) => boolean;
    // (undocumented)
    htmlDeserializer: HtmlDeserializer;
    // (undocumented)
    insertBetweenBlocks: (blockEntry: NodeEntry, edge: 'before' | 'after') => void;
    // (undocumented)
    isDefaultElement: (element: Element_2) => boolean;
    // (undocumented)
    isElementActive: <E extends Element_2>(elementType: E['type'], suchThat?: Partial<E>) => boolean;
    // (undocumented)
    onBlur: (event: FocusEvent_2<HTMLDivElement>) => void;
    // (undocumented)
    onDOMBeforeInput: (event: Event) => void;
    // (undocumented)
    onFocus: (event: FocusEvent_2<HTMLDivElement>) => void;
    // (undocumented)
    onKeyDown: (event: KeyboardEvent_2<HTMLDivElement>) => void;
    // (undocumented)
    registerElement: (plugin: CustomElementPlugin<any>) => void;
    // (undocumented)
    registerMark: (plugin: CustomMarkPlugin) => void;
    // (undocumented)
    renderElement: (props: RenderElementProps) => ReactElement;
    // (undocumented)
    renderLeaf: (props: RenderLeafProps) => ReactElement;
    // (undocumented)
    renderLeafChildren: (props: Omit<RenderLeafProps, 'attributes'>) => ReactElement;
    // (undocumented)
    serializeNodes: (nodes: Array<Descendant>, errorMessage?: string) => string;
    // (undocumented)
    toggleElement: <E extends Element_2>(elementType: E['type'], suchThat?: Partial<E>) => void;
    // (undocumented)
    toggleMarks: <T extends Text_2>(marks: TextSpecifics<T>) => void;
    // (undocumented)
    upgradeFormatBySingleVersion: (node: Node_2, oldVersion: number) => Node_2;
}

// @public (undocumented)
export const withHeadings: ({ render }: {
    render: ElementRenderer<HeadingElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withHighlight: <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withHorizontalRules: ({ render }: {
    render: ElementRenderer<HorizontalRuleElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withItalic: <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withLists: ({ renderListItem, renderUnorderedList, renderOrderedList }: {
    renderListItem: ElementRenderer<ListItemElement>;
    renderOrderedList: ElementRenderer<OrderedListElement>;
    renderUnorderedList: ElementRenderer<UnorderedListElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withNewline: <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withParagraphs: ({ render }: {
    render: ElementRenderer<ParagraphElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withPaste: <E extends Editor_2>(editor: E) => asserts editor is E;

// @public (undocumented)
export const withScrollTargets: ({ render }: {
    render: ElementRenderer<ScrollTargetElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withStrikeThrough: <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withTables: ({ renderTable, renderTableCell, renderTableRow }: {
    renderTable: ElementRenderer<TableElement>;
    renderTableCell: ElementRenderer<TableCellElement>;
    renderTableRow: ElementRenderer<TableRowElement>;
}) => <E extends Editor>(editor: E) => E;

// @public (undocumented)
export const withUnderline: <E extends Editor>(editor: E) => E;

// Warnings were encountered during analysis:
//
// src/blockEditor/embed/index.ts:5:27 - (ae-forgotten-export) The symbol "GoogleFormEmbedHandler" needs to be exported by the entry point index.d.ts
// src/blockEditor/embed/index.ts:5:27 - (ae-forgotten-export) The symbol "YouTubeEmbedHandler" needs to be exported by the entry point index.d.ts
// src/blockEditor/embed/index.ts:5:27 - (ae-forgotten-export) The symbol "VimeoEmbedHandler" needs to be exported by the entry point index.d.ts
// src/blockEditor/embed/index.ts:5:27 - (ae-forgotten-export) The symbol "SoundCloudEmbedHandler" needs to be exported by the entry point index.d.ts
// src/blockEditor/embed/index.ts:5:27 - (ae-forgotten-export) The symbol "SpotifyEmbedHandler" needs to be exported by the entry point index.d.ts
// src/blockEditor/templating/getEditorTemplate.tsx:16:3 - (ae-forgotten-export) The symbol "EditorTemplateAtom" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
